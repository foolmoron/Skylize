// Generated by CoffeeScript 1.7.1
var Grid;

Grid = IgeEntity.extend({
  classId: 'Grid',
  MOUSE_POSITION_HACK_X: -15,
  MOUSE_POSITION_HACK_Y: -75,
  PICKER_OFFSETX: 100,
  PICKER_OFFSETY: -65,
  PICKER_GAPX: 60,
  PICKER_SIZE: 50,
  PICKER_FADE_OPACITY: 0.25,
  VELOCITY_TIERS: [7, 16, 26, 36, 46, 55],
  init: function(_gridSize, _tileSize) {
    var color, colors, i, j, key, light, newTile, pickerX, row, self, value, _i, _j, _k, _len, _ref, _ref1;
    this._gridSize = _gridSize;
    this._tileSize = _tileSize;
    IgeEntity.prototype.init.call(this);
    self = this;
    this.pickers = {};
    pickerX = this.PICKER_OFFSETX;
    colors = (function() {
      var _ref, _results;
      _ref = Light.COLOR;
      _results = [];
      for (key in _ref) {
        value = _ref[key];
        _results.push(value);
      }
      return _results;
    })();
    colors.push('all');
    for (_i = 0, _len = colors.length; _i < _len; _i++) {
      color = colors[_i];
      self.pickers[color] = new IgeEntity().texture(SL.tex['picker' + color]).width(self.PICKER_SIZE).height(self.PICKER_SIZE).opacity(self.PICKER_FADE_OPACITY).mouseDown(function() {
        var picker, _ref, _results;
        self._currentColor = this._color;
        _ref = self.pickers;
        _results = [];
        for (key in _ref) {
          picker = _ref[key];
          if (key === this._color) {
            _results.push(picker.opacity(1));
          } else {
            _results.push(picker.opacity(self.PICKER_FADE_OPACITY));
          }
        }
        return _results;
      }).translateTo(pickerX, self.PICKER_OFFSETY, 0).mount(self);
      self.pickers[color]._color = color;
      pickerX += this.PICKER_GAPX;
    }
    this.pickers['all'].mouseDown().call(this.pickers['all']);
    this._grid = [];
    for (i = _j = 0, _ref = this._gridSize; 0 <= _ref ? _j <= _ref : _j >= _ref; i = 0 <= _ref ? ++_j : --_j) {
      row = [];
      this._grid.push(row);
      for (j = _k = 0, _ref1 = this._gridSize; 0 <= _ref1 ? _k <= _ref1 : _k >= _ref1; j = 0 <= _ref1 ? ++_k : --_k) {
        newTile = new Tile(this._tileSize).id("" + i + "x" + j).translateTo(i * this._tileSize, j * this._tileSize, 0).depth(i * this._gridSize + j).mount(this);
        row.push(newTile);
        if (i === this._gridSize && j === this._gridSize) {
          for (light in newTile._lights) {
            newTile._lights[light].destroy();
            delete newTile._lights[light];
          }
        } else if (i === this._gridSize) {
          for (light in newTile._lights) {
            if (!(light !== 'l')) {
              continue;
            }
            newTile._lights[light].destroy();
            delete newTile._lights[light];
          }
        } else if (j === this._gridSize) {
          for (light in newTile._lights) {
            if (!(light !== 't')) {
              continue;
            }
            newTile._lights[light].destroy();
            delete newTile._lights[light];
          }
        }
      }
    }
    this._painting = false;
    this._lastTouch = null;
    return this._mouseEventCatcher = new IgeEntity().width((this._gridSize + 1) * this._tileSize).height((this._gridSize + 1) * this._tileSize).translateTo((SL.GRID_SIZE / 2 - 0.5) * SL.TILE_SIZE, (SL.GRID_SIZE / 2 - 0.5) * SL.TILE_SIZE, 0).mouseDown((function(_this) {
      return function(evt) {
        var point;
        point = {
          x: evt.x + _this.MOUSE_POSITION_HACK_X,
          y: evt.y + _this.MOUSE_POSITION_HACK_Y
        };
        if (point.x >= 0 && point.y >= 0) {
          return _this.handleDown(evt, point);
        }
      };
    })(this)).mouseMove((function(_this) {
      return function(evt) {
        var point;
        point = {
          x: evt.x + _this.MOUSE_POSITION_HACK_X,
          y: evt.y + _this.MOUSE_POSITION_HACK_Y
        };
        if (point.x >= 0 && point.y >= 0) {
          return _this.handleMove(evt, point);
        }
      };
    })(this)).mouseUp((function(_this) {
      return function(evt) {
        var point;
        point = {
          x: evt.x + _this.MOUSE_POSITION_HACK_X,
          y: evt.y + _this.MOUSE_POSITION_HACK_Y
        };
        if (point.x >= 0 && point.y >= 0) {
          return _this.handleUp(evt, point);
        }
      };
    })(this)).mount(this);
  },
  handleDown: function(evt, point) {
    this._painting = true;
    return this._lastTouch = point;
  },
  handleMove: function(evt, point) {
    var currentColor, displacement, light, tier, tile, tilePos, velocity, velocityTier, _i, _len, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _results, _results1, _results2;
    if (!this._painting) {
      return;
    }
    tilePos = {
      x: Math.floor(point.x / this._tileSize),
      y: Math.floor(point.y / this._tileSize)
    };
    tile = this._grid[tilePos.x][tilePos.y];
    displacement = {
      x: this._lastTouch.x - point.x,
      y: this._lastTouch.y - point.y
    };
    velocity = Math.abs(displacement.x) + Math.abs(displacement.y);
    velocityTier = 0;
    _ref = this.VELOCITY_TIERS;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      tier = _ref[_i];
      if (tier <= velocity) {
        velocityTier++;
      }
    }
    this._lastTouch = point;
    currentColor = this._currentColor;
    switch (velocityTier) {
      case 0:
        if (currentColor === 'all') {
          currentColor = Light.COLOR.RED;
        }
        for (light in tile._lights) {
          if (light === 't' || light === 'l' || light === 'f' || light === 'b' || light === 'h' || light === 'v') {
            tile._lights[light].color(currentColor);
          }
        }
        if ((_ref1 = this._grid[tilePos.x + 1]) != null) {
          if ((_ref2 = _ref1[tilePos.y]) != null) {
            if ((_ref3 = _ref2._lights['l']) != null) {
              _ref3.color(currentColor);
            }
          }
        }
        return (_ref4 = this._grid[tilePos.x]) != null ? (_ref5 = _ref4[tilePos.y + 1]) != null ? (_ref6 = _ref5._lights['t']) != null ? _ref6.color(currentColor) : void 0 : void 0 : void 0;
      case 1:
        if (currentColor === 'all') {
          currentColor = Light.COLOR.BLUE;
        }
        for (light in tile._lights) {
          if (light === 't' || light === 'l' || light === 'f' || light === 'b') {
            tile._lights[light].color(currentColor);
          }
        }
        if ((_ref7 = this._grid[tilePos.x + 1]) != null) {
          if ((_ref8 = _ref7[tilePos.y]) != null) {
            if ((_ref9 = _ref8._lights['l']) != null) {
              _ref9.color(currentColor);
            }
          }
        }
        return (_ref10 = this._grid[tilePos.x]) != null ? (_ref11 = _ref10[tilePos.y + 1]) != null ? (_ref12 = _ref11._lights['t']) != null ? _ref12.color(currentColor) : void 0 : void 0 : void 0;
      case 2:
        if (currentColor === 'all') {
          currentColor = Light.COLOR.WHITE;
        }
        for (light in tile._lights) {
          if (light === 't' || light === 'l') {
            tile._lights[light].color(currentColor);
          }
        }
        if ((_ref13 = this._grid[tilePos.x + 1]) != null) {
          if ((_ref14 = _ref13[tilePos.y]) != null) {
            if ((_ref15 = _ref14._lights['l']) != null) {
              _ref15.color(currentColor);
            }
          }
        }
        return (_ref16 = this._grid[tilePos.x]) != null ? (_ref17 = _ref16[tilePos.y + 1]) != null ? (_ref18 = _ref17._lights['t']) != null ? _ref18.color(currentColor) : void 0 : void 0 : void 0;
      case 3:
        if (currentColor === 'all') {
          currentColor = Light.COLOR.PINK;
        }
        _results = [];
        for (light in tile._lights) {
          if (light === 'f' || light === 'b') {
            _results.push(tile._lights[light].color(currentColor));
          }
        }
        return _results;
        break;
      case 4:
        if (currentColor === 'all') {
          currentColor = Light.COLOR.GREEN;
        }
        _results1 = [];
        for (light in tile._lights) {
          if (light === 'h' || light === 'v') {
            _results1.push(tile._lights[light].color(currentColor));
          }
        }
        return _results1;
        break;
      case 5:
        if (currentColor === 'all') {
          currentColor = Light.COLOR.YELLOW;
        }
        _results2 = [];
        for (light in tile._lights) {
          if (light === 'h') {
            _results2.push(tile._lights[light].color(currentColor));
          }
        }
        return _results2;
    }
  },
  handleUp: function(evt, point) {
    this._painting = false;
    return this._lastTouch = null;
  },
  serialize: function() {
    var bareGrid, i, j, light, row, tile, tileDescriptor, _i, _j, _ref, _ref1;
    bareGrid = [];
    for (i = _i = 0, _ref = this._gridSize; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      row = [];
      bareGrid.push(row);
      for (j = _j = 0, _ref1 = this._gridSize; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
        tile = this._grid[i][j];
        tileDescriptor = "";
        for (light in tile._lights) {
          if (tile._lights[light].color() !== Light.COLOR.NONE) {
            tileDescriptor += light + tile._lights[light].color();
          }
        }
        row.push(tileDescriptor);
      }
    }
    return btoa(JSON.stringify(bareGrid));
  },
  deserialize: function(string) {
    var color, element, error, i, j, json, k, light, row, tile, tileDescriptor, _i, _j, _k, _l, _len, _ref, _ref1, _ref2;
    json = (function() {
      try {
        return JSON.parse(atob(string));
      } catch (_error) {
        error = _error;
        return null;
      }
    })();
    if (json == null) {
      return;
    }
    if (json.length !== (this._gridSize + 1)) {
      return;
    }
    for (_i = 0, _len = json.length; _i < _len; _i++) {
      element = json[_i];
      if (element.length !== (this._gridSize + 1)) {
        return;
      }
    }
    for (i = _j = 0, _ref = this._gridSize; 0 <= _ref ? _j <= _ref : _j >= _ref; i = 0 <= _ref ? ++_j : --_j) {
      row = this._grid[i];
      for (j = _k = 0, _ref1 = this._gridSize; 0 <= _ref1 ? _k <= _ref1 : _k >= _ref1; j = 0 <= _ref1 ? ++_k : --_k) {
        try {
          tile = row[j];
          for (light in tile._lights) {
            if (light === 't' || light === 'l' || light === 'f' || light === 'b' || light === 'h' || light === 'v') {
              tile._lights[light].color(Light.COLOR.NONE);
            }
          }
          tileDescriptor = json[i][j];
          if (tileDescriptor.length > 0) {
            for (k = _l = 1, _ref2 = tileDescriptor.length; _l <= _ref2; k = _l += 2) {
              light = tileDescriptor[k - 1];
              color = tileDescriptor[k];
              tile._lights[light].color(color);
            }
          }
        } catch (_error) {
          error = _error;
        }
      }
    }
    return true;
  }
});

if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
  module.exports = Grid;
}
